#!/usr/bin/env python3
"""
Prototype text-on-path outliner for Clean Slate.

Produces per-glyph DrawingML path snippets positioned and rotated along an
SVG path. This is an initial implementation aligned with ADR-011 that relies
on existing conversion services (unit converter, path sampling, glyph to path
generation). It keeps the implementation self-contained so it can evolve
alongside future HarfBuzz integrations.
"""

from __future__ import annotations

import math
from dataclasses import dataclass
from typing import List, Optional

from ..ir.font_metadata import create_font_metadata
from ..ir.text_path import CharacterPlacement, TextPathFrame
from ..services.conversion_services import ConversionServices
from ..services.path_generation_service import create_path_generation_service
from ..services.text_layout_engine import create_text_layout_engine
from ..services.text_path_processor import create_text_path_processor
from ..services.text_to_path_processor import create_text_to_path_processor


@dataclass(frozen=True)
class GlyphOutlineResult:
    """DrawingML glyph outline positioned along a path."""

    character: str
    path_xml: str
    x_emu: int
    y_emu: int
    rotation_60000: int


class TextPathOutliner:
    """
    Convert text-on-path runs into positioned glyph outlines.

    The class samples the text path, runs character placement using
    `TextPathProcessor`, and transforms individual glyph outlines generated by
    the path generation service.
    """

    def __init__(self, services: Optional[ConversionServices] = None):
        self.services = self._require_services(services)
        self.unit_converter = getattr(self.services, "unit_converter", None)
        if self.unit_converter is None:
            raise RuntimeError(
                "TextPathOutliner requires ConversionServices.unit_converter; received services without one.",
            )

        font_system = getattr(self.services, "font_system", None)
        path_processor = getattr(self.services, "path_processor", None)
        font_processor = getattr(self.services, "font_processor", None)

        text_layout_engine = create_text_layout_engine(
            self.unit_converter,
            font_processor,
            services=self.services,
        )

        self.text_path_processor = create_text_path_processor(
            font_system=font_system,
            text_layout_engine=text_layout_engine,
            path_processor=path_processor,
        )

        self.path_generator = create_path_generation_service(font_system=font_system)
        self.text_to_path_processor = create_text_to_path_processor(
            font_system=font_system,
            text_layout_engine=text_layout_engine,
            path_generator=self.path_generator,
        )

    def outline_text_on_path(
        self,
        text_path: TextPathFrame,
        path_data: str,
    ) -> List[GlyphOutlineResult]:
        """Return positioned glyph outlines for the provided text path."""
        processing_result = self.text_path_processor.process_text_path(text_path, path_data)
        placements = processing_result.layout.character_placements

        outlines: List[GlyphOutlineResult] = []
        if not placements:
            return outlines

        for placement in placements:
            glyph_outline = self._outline_glyph(text_path, placement)
            if glyph_outline:
                outlines.append(glyph_outline)

        return outlines

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _outline_glyph(
        self,
        text_path: TextPathFrame,
        placement: CharacterPlacement,
    ) -> Optional[GlyphOutlineResult]:
        """Generate an outlined glyph positioned along the path."""
        char = placement.character

        try:
            run = text_path.runs[placement.run_index]
        except IndexError:
            run = text_path.runs[0]

        font_family = getattr(run, "font_family", None) or "Arial"
        font_size = getattr(run, "font_size_pt", 12.0)
        font_metadata = create_font_metadata(font_family, size_pt=font_size)

        path_result = self.path_generator.generate_text_path(
            char,
            [font_family],
            font_size,
        )

        if path_result is None or not path_result.drawingml_path:
            return None

        x_emu = self._to_emu(placement.position.x, axis="x")
        y_emu = self._to_emu(placement.position.y, axis="y")

        # Apply baseline offsets (global + per glyph) along the normal vector.
        baseline_offset = text_path.baseline_offset + placement.baseline_offset
        if baseline_offset:
            angle = placement.position.normal_angle
            if not angle:
                angle = placement.position.tangent_angle + math.pi / 2.0
            offset_emu = self._to_emu(baseline_offset)
            x_emu += int(offset_emu * math.cos(angle))
            y_emu += int(offset_emu * math.sin(angle))

        rotation = int(round(placement.effective_rotation * 60000))

        return GlyphOutlineResult(
            character=char,
            path_xml=path_result.drawingml_path,
            x_emu=x_emu,
            y_emu=y_emu,
            rotation_60000=rotation,
        )

    def _to_emu(self, value: float, axis: str = "uniform") -> int:
        """Convert SVG units (px) to EMU using ConversionServices."""
        if value == 0:
            return 0

        dpi = getattr(self.unit_converter.default_context, "dpi", None)
        if dpi is None:
            raise RuntimeError(
                "ConversionServices.unit_converter.default_context is missing dpi; "
                "cannot convert pixels to EMU.",
            )

        points = (float(value) / dpi) * 72.0
        return self.services.emu(points, axis=axis).value

    def _require_services(self, services: Optional[ConversionServices]) -> ConversionServices:
        """Ensure a ConversionServices instance is provided."""
        if services is None:
            raise RuntimeError(
                "TextPathOutliner requires a ConversionServices instance; received None.",
            )
        if not hasattr(services, "emu"):
            raise RuntimeError(
                "ConversionServices instance for TextPathOutliner must expose an `emu` method.",
            )
        return services
