#!/usr/bin/env python3
"""
Mesh Gradient DrawingML Output Validation Tests

Validates the quality and correctness of DrawingML output generated by the mesh gradient engine.
Tests structural validity, XML compliance, PowerPoint compatibility, and visual fidelity.

Tests include:
- DrawingML XML schema validation
- PowerPoint compatibility checks
- Gradient stop accuracy and positioning
- Color space conversion validation
- Alpha channel handling verification
- Path and geometry structure validation
- Template compliance testing

Quality Standards:
- XML structural validity: 100%
- PowerPoint compatibility: 100%
- Color accuracy: Î”E < 2.0 for interpolated colors
- Position accuracy: < 1% deviation from expected
- Alpha precision: < 0.1% error in opacity values
"""

import unittest
import pytest
from pathlib import Path
import sys
import re
from typing import List, Dict, Tuple, Optional
from lxml import etree as ET
from dataclasses import dataclass

# Add src to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))

try:
    from src.converters.gradients.mesh_engine import MeshGradientEngine, ColorInterpolator, MeshPatch
    from src.converters.gradients.converter import GradientConverter
    from src.converters.base import ConversionContext
    from core.services.conversion_services import ConversionServices
    MESH_GRADIENT_AVAILABLE = True
except ImportError:
    MESH_GRADIENT_AVAILABLE = False


@dataclass
class DrawingMLValidationResult:
    """Result of DrawingML validation"""
    is_valid: bool
    error_message: Optional[str] = None
    warnings: List[str] = None
    structure_score: float = 0.0
    compatibility_score: float = 0.0


class DrawingMLValidator:
    """Validator for DrawingML gradient output"""

    @staticmethod
    def validate_xml_structure(xml_content: str) -> DrawingMLValidationResult:
        """Validate basic XML structure and syntax"""
        try:
            # Wrap in namespaced root for validation
            wrapped_xml = f'''<?xml version="1.0" encoding="UTF-8"?>
<root xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
{xml_content}
</root>'''

            root = ET.fromstring(wrapped_xml)
            return DrawingMLValidationResult(is_valid=True, structure_score=1.0)

        except ET.XMLSyntaxError as e:
            return DrawingMLValidationResult(
                is_valid=False,
                error_message=f"XML syntax error: {e}",
                structure_score=0.0
            )

    @staticmethod
    def validate_gradient_structure(xml_content: str) -> DrawingMLValidationResult:
        """Validate DrawingML gradient structure"""
        warnings = []

        # Check for required gradient elements
        if not ('gradFill' in xml_content or 'solidFill' in xml_content):
            return DrawingMLValidationResult(
                is_valid=False,
                error_message="No gradient or solid fill element found"
            )

        if 'gradFill' in xml_content:
            # Validate gradient structure
            if '<a:gsLst>' not in xml_content:
                warnings.append("Gradient missing gradient stop list")

            if '<a:gs pos=' not in xml_content:
                warnings.append("Gradient missing gradient stops")

            # Check for path or linear element
            has_path = '<a:path' in xml_content
            has_linear = '<a:lin' in xml_content

            if not (has_path or has_linear):
                warnings.append("Gradient missing path or linear element")

        compatibility_score = 1.0 - (len(warnings) * 0.2)

        return DrawingMLValidationResult(
            is_valid=True,
            warnings=warnings,
            compatibility_score=max(0.0, compatibility_score)
        )

    @staticmethod
    def validate_color_values(xml_content: str) -> DrawingMLValidationResult:
        """Validate color values in DrawingML output"""
        import re

        # Extract color values
        color_pattern = r'val="([A-Fa-f0-9]{6})"'
        colors = re.findall(color_pattern, xml_content)

        warnings = []

        for color in colors:
            # Validate hex color format
            if len(color) != 6:
                warnings.append(f"Invalid color format: {color}")
                continue

            try:
                # Convert to RGB to validate
                r = int(color[0:2], 16)
                g = int(color[2:4], 16)
                b = int(color[4:6], 16)

                # Check for valid RGB ranges
                if not all(0 <= c <= 255 for c in [r, g, b]):
                    warnings.append(f"Color out of range: {color}")

            except ValueError:
                warnings.append(f"Invalid hex color: {color}")

        accuracy_score = 1.0 - (len(warnings) * 0.1)

        return DrawingMLValidationResult(
            is_valid=len(warnings) == 0,
            warnings=warnings,
            structure_score=max(0.0, accuracy_score)
        )

    @staticmethod
    def validate_position_values(xml_content: str) -> DrawingMLValidationResult:
        """Validate position values in gradient stops"""
        import re

        # Extract position values
        pos_pattern = r'pos="(\d+)"'
        positions = re.findall(pos_pattern, xml_content)

        warnings = []

        for pos_str in positions:
            try:
                pos = int(pos_str)

                # Position should be between 0 and 100000 (per-mille)
                if not (0 <= pos <= 100000):
                    warnings.append(f"Position out of range: {pos}")

            except ValueError:
                warnings.append(f"Invalid position value: {pos_str}")

        # Check position ordering if multiple positions
        if len(positions) > 1:
            pos_values = [int(p) for p in positions if p.isdigit()]
            if pos_values != sorted(pos_values):
                warnings.append("Gradient stops not in ascending order")

        accuracy_score = 1.0 - (len(warnings) * 0.2)

        return DrawingMLValidationResult(
            is_valid=len(warnings) == 0,
            warnings=warnings,
            structure_score=max(0.0, accuracy_score)
        )

    @staticmethod
    def validate_alpha_values(xml_content: str) -> DrawingMLValidationResult:
        """Validate alpha values in DrawingML output"""
        import re

        # Extract alpha values
        alpha_pattern = r'alpha="(\d+)"'
        alphas = re.findall(alpha_pattern, xml_content)

        warnings = []

        for alpha_str in alphas:
            try:
                alpha = int(alpha_str)

                # Alpha should be between 0 and 100000 (per-mille)
                if not (0 <= alpha <= 100000):
                    warnings.append(f"Alpha out of range: {alpha}")

            except ValueError:
                warnings.append(f"Invalid alpha value: {alpha_str}")

        accuracy_score = 1.0 - (len(warnings) * 0.2)

        return DrawingMLValidationResult(
            is_valid=len(warnings) == 0,
            warnings=warnings,
            structure_score=max(0.0, accuracy_score)
        )


@pytest.mark.skipif(not MESH_GRADIENT_AVAILABLE, reason="Mesh gradient system not available")
class TestMeshGradientDrawingMLValidation:
    """Test DrawingML output validation for mesh gradients"""

    def setup_method(self):
        """Set up test fixtures"""
        self.engine = MeshGradientEngine()
        self.validator = DrawingMLValidator()
        self.services = ConversionServices.create_default()

    def test_simple_mesh_gradient_xml_validity(self):
        """Test XML validity of simple mesh gradient output"""
        mesh_svg = '''<meshgradient xmlns="http://www.w3.org/2000/svg" id="simple">
            <meshrow>
                <meshpatch>
                    <stop offset="0" stop-color="#FF0000" stop-opacity="1.0"/>
                    <stop offset="0" stop-color="#00FF00" stop-opacity="1.0"/>
                    <stop offset="1" stop-color="#0000FF" stop-opacity="1.0"/>
                    <stop offset="1" stop-color="#FFFF00" stop-opacity="1.0"/>
                </meshpatch>
            </meshrow>
        </meshgradient>'''

        element = ET.fromstring(mesh_svg)
        result = self.engine.convert_mesh_gradient(element)

        # Validate XML structure
        validation_result = self.validator.validate_xml_structure(result)
        assert validation_result.is_valid, f"Invalid XML: {validation_result.error_message}"
        assert validation_result.structure_score >= 1.0

    def test_simple_mesh_gradient_structure_validity(self):
        """Test DrawingML structure validity of simple mesh gradient"""
        mesh_svg = '''<meshgradient xmlns="http://www.w3.org/2000/svg" id="simple">
            <meshrow>
                <meshpatch>
                    <stop offset="0" stop-color="#FF0000" stop-opacity="1.0"/>
                    <stop offset="0" stop-color="#00FF00" stop-opacity="1.0"/>
                    <stop offset="1" stop-color="#0000FF" stop-opacity="1.0"/>
                    <stop offset="1" stop-color="#FFFF00" stop-opacity="1.0"/>
                </meshpatch>
            </meshrow>
        </meshgradient>'''

        element = ET.fromstring(mesh_svg)
        result = self.engine.convert_mesh_gradient(element)

        # Validate gradient structure
        validation_result = self.validator.validate_gradient_structure(result)
        assert validation_result.is_valid
        assert validation_result.compatibility_score >= 0.8

    def test_complex_mesh_gradient_xml_validity(self):
        """Test XML validity of complex mesh gradient output"""
        mesh_svg = '''<meshgradient xmlns="http://www.w3.org/2000/svg" id="complex">
            <meshrow>
                <meshpatch>
                    <stop stop-color="#FF0000" stop-opacity="1.0"/>
                    <stop stop-color="#00FF00" stop-opacity="0.8"/>
                    <stop stop-color="#0000FF" stop-opacity="0.6"/>
                    <stop stop-color="#FFFF00" stop-opacity="0.4"/>
                </meshpatch>
                <meshpatch>
                    <stop stop-color="#800000" stop-opacity="1.0"/>
                    <stop stop-color="#008000" stop-opacity="0.7"/>
                    <stop stop-color="#000080" stop-opacity="0.5"/>
                    <stop stop-color="#808000" stop-opacity="0.3"/>
                </meshpatch>
            </meshrow>
        </meshgradient>'''

        element = ET.fromstring(mesh_svg)
        result = self.engine.convert_mesh_gradient(element)

        # Validate XML structure
        validation_result = self.validator.validate_xml_structure(result)
        assert validation_result.is_valid, f"Invalid XML: {validation_result.error_message}"

    def test_mesh_gradient_color_value_validation(self):
        """Test color value validation in mesh gradient output"""
        mesh_svg = '''<meshgradient xmlns="http://www.w3.org/2000/svg" id="colors">
            <meshrow>
                <meshpatch>
                    <stop stop-color="#FF0000"/>
                    <stop stop-color="#00FF00"/>
                    <stop stop-color="#0000FF"/>
                    <stop stop-color="#FFFFFF"/>
                </meshpatch>
            </meshrow>
        </meshgradient>'''

        element = ET.fromstring(mesh_svg)
        result = self.engine.convert_mesh_gradient(element)

        # Validate color values
        validation_result = self.validator.validate_color_values(result)
        assert validation_result.is_valid, f"Invalid colors: {validation_result.warnings}"
        assert validation_result.structure_score >= 0.9

    def test_mesh_gradient_position_validation(self):
        """Test position value validation in mesh gradient output"""
        mesh_svg = '''<meshgradient xmlns="http://www.w3.org/2000/svg" id="positions">
            <meshrow>
                <meshpatch>
                    <stop offset="0" stop-color="#FF0000"/>
                    <stop offset="0.33" stop-color="#00FF00"/>
                    <stop offset="0.66" stop-color="#0000FF"/>
                    <stop offset="1" stop-color="#FFFFFF"/>
                </meshpatch>
            </meshrow>
        </meshgradient>'''

        element = ET.fromstring(mesh_svg)
        result = self.engine.convert_mesh_gradient(element)

        # Validate position values
        validation_result = self.validator.validate_position_values(result)
        assert validation_result.is_valid, f"Invalid positions: {validation_result.warnings}"
        assert validation_result.structure_score >= 0.8

    def test_mesh_gradient_alpha_validation(self):
        """Test alpha value validation in mesh gradient output"""
        mesh_svg = '''<meshgradient xmlns="http://www.w3.org/2000/svg" id="alpha">
            <meshrow>
                <meshpatch>
                    <stop stop-color="#FF0000" stop-opacity="1.0"/>
                    <stop stop-color="#00FF00" stop-opacity="0.8"/>
                    <stop stop-color="#0000FF" stop-opacity="0.6"/>
                    <stop stop-color="#FFFFFF" stop-opacity="0.4"/>
                </meshpatch>
            </meshrow>
        </meshgradient>'''

        element = ET.fromstring(mesh_svg)
        result = self.engine.convert_mesh_gradient(element)

        # Validate alpha values
        validation_result = self.validator.validate_alpha_values(result)
        assert validation_result.is_valid, f"Invalid alphas: {validation_result.warnings}"
        assert validation_result.structure_score >= 0.8

    def test_fallback_solid_fill_validation(self):
        """Test validation of fallback solid fill output"""
        # Empty mesh gradient should produce solid fill
        mesh_svg = '<meshgradient xmlns="http://www.w3.org/2000/svg" id="empty"/>'

        element = ET.fromstring(mesh_svg)
        result = self.engine.convert_mesh_gradient(element)

        # Should be solid fill
        assert 'solidFill' in result

        # Validate structure
        validation_result = self.validator.validate_xml_structure(result)
        assert validation_result.is_valid

        # Validate gradient structure (should accept solid fill)
        structure_result = self.validator.validate_gradient_structure(result)
        assert structure_result.is_valid

    def test_gradient_converter_integration_validation(self):
        """Test validation of GradientConverter mesh integration output"""
        converter = GradientConverter(self.services)

        mesh_svg = '''<meshgradient xmlns="http://www.w3.org/2000/svg" id="integration">
            <meshrow>
                <meshpatch>
                    <stop stop-color="#FF0000"/>
                    <stop stop-color="#00FF00"/>
                    <stop stop-color="#0000FF"/>
                    <stop stop-color="#FFFF00"/>
                </meshpatch>
            </meshrow>
        </meshgradient>'''

        element = ET.fromstring(mesh_svg)

        # Create context
        svg_root = ET.Element('svg')
        svg_root.append(element)
        context = ConversionContext(services=self.services, svg_root=svg_root)

        # Convert through GradientConverter
        result = converter.convert(element, context)

        # Validate all aspects
        xml_validation = self.validator.validate_xml_structure(result)
        structure_validation = self.validator.validate_gradient_structure(result)
        color_validation = self.validator.validate_color_values(result)

        assert xml_validation.is_valid
        assert structure_validation.is_valid
        assert color_validation.is_valid

    def test_url_reference_validation(self):
        """Test validation of URL reference resolution output"""
        converter = GradientConverter(self.services)

        svg_content = '''<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
            <defs>
                <meshgradient id="urlTest">
                    <meshrow>
                        <meshpatch>
                            <stop stop-color="#FF0000"/>
                            <stop stop-color="#00FF00"/>
                            <stop stop-color="#0000FF"/>
                            <stop stop-color="#FFFF00"/>
                        </meshpatch>
                    </meshrow>
                </meshgradient>
            </defs>
        </svg>'''

        svg_root = ET.fromstring(svg_content)
        context = ConversionContext(services=self.services, svg_root=svg_root)

        # Test URL reference resolution
        result = converter.get_fill_from_url('url(#urlTest)', context)

        # Validate output
        validation_result = self.validator.validate_xml_structure(result)
        assert validation_result.is_valid

        structure_result = self.validator.validate_gradient_structure(result)
        assert structure_result.is_valid

    def test_edge_case_validation(self):
        """Test validation with edge cases and error conditions"""
        test_cases = [
            # Single color mesh
            '''<meshgradient xmlns="http://www.w3.org/2000/svg">
                <meshrow>
                    <meshpatch>
                        <stop stop-color="#FF0000"/>
                        <stop stop-color="#FF0000"/>
                        <stop stop-color="#FF0000"/>
                        <stop stop-color="#FF0000"/>
                    </meshpatch>
                </meshrow>
            </meshgradient>''',

            # Extreme opacity values
            '''<meshgradient xmlns="http://www.w3.org/2000/svg">
                <meshrow>
                    <meshpatch>
                        <stop stop-color="#FF0000" stop-opacity="0.0"/>
                        <stop stop-color="#00FF00" stop-opacity="0.01"/>
                        <stop stop-color="#0000FF" stop-opacity="0.99"/>
                        <stop stop-color="#FFFFFF" stop-opacity="1.0"/>
                    </meshpatch>
                </meshrow>
            </meshgradient>''',

            # Unusual color formats
            '''<meshgradient xmlns="http://www.w3.org/2000/svg">
                <meshrow>
                    <meshpatch>
                        <stop stop-color="rgb(255, 0, 0)"/>
                        <stop stop-color="hsl(120, 100%, 50%)"/>
                        <stop stop-color="#0000FF"/>
                        <stop stop-color="#fff"/>
                    </meshpatch>
                </meshrow>
            </meshgradient>'''
        ]

        for i, mesh_svg in enumerate(test_cases):
            element = ET.fromstring(mesh_svg)
            result = self.engine.convert_mesh_gradient(element)

            # All should produce valid output
            validation_result = self.validator.validate_xml_structure(result)
            assert validation_result.is_valid, f"Test case {i} failed XML validation"

            structure_result = self.validator.validate_gradient_structure(result)
            assert structure_result.is_valid, f"Test case {i} failed structure validation"

    def test_powerpoint_compatibility_validation(self):
        """Test PowerPoint-specific compatibility requirements"""
        mesh_svg = '''<meshgradient xmlns="http://www.w3.org/2000/svg" id="pptx">
            <meshrow>
                <meshpatch>
                    <stop stop-color="#FF0000"/>
                    <stop stop-color="#00FF00"/>
                    <stop stop-color="#0000FF"/>
                    <stop stop-color="#FFFF00"/>
                </meshpatch>
            </meshrow>
        </meshgradient>'''

        element = ET.fromstring(mesh_svg)
        result = self.engine.convert_mesh_gradient(element)

        # Check PowerPoint-specific requirements
        requirements_met = []

        # Should use DrawingML namespace prefixes
        requirements_met.append('a:' in result)

        # Should have proper gradient structure
        if 'gradFill' in result:
            requirements_met.extend([
                '<a:gsLst>' in result,
                '<a:gs pos=' in result,
                'a:srgbClr' in result
            ])

        # Should use proper coordinate system (EMU-based positions)
        import re
        positions = re.findall(r'pos="(\d+)"', result)
        if positions:
            # Positions should be in per-mille (0-100000)
            valid_positions = all(0 <= int(pos) <= 100000 for pos in positions)
            requirements_met.append(valid_positions)

        # Most requirements should be met
        compatibility_score = sum(requirements_met) / len(requirements_met)
        assert compatibility_score >= 0.8, f"PowerPoint compatibility score too low: {compatibility_score}"

    def test_comprehensive_validation_score(self):
        """Test comprehensive validation scoring for mesh gradient output"""
        mesh_svg = '''<meshgradient xmlns="http://www.w3.org/2000/svg" id="comprehensive">
            <meshrow>
                <meshpatch>
                    <stop offset="0" stop-color="#FF0000" stop-opacity="1.0"/>
                    <stop offset="0" stop-color="#00FF00" stop-opacity="0.8"/>
                    <stop offset="1" stop-color="#0000FF" stop-opacity="0.6"/>
                    <stop offset="1" stop-color="#FFFF00" stop-opacity="0.4"/>
                </meshpatch>
            </meshrow>
        </meshgradient>'''

        element = ET.fromstring(mesh_svg)
        result = self.engine.convert_mesh_gradient(element)

        # Run all validations
        xml_result = self.validator.validate_xml_structure(result)
        structure_result = self.validator.validate_gradient_structure(result)
        color_result = self.validator.validate_color_values(result)
        position_result = self.validator.validate_position_values(result)
        alpha_result = self.validator.validate_alpha_values(result)

        # Calculate overall score
        scores = [
            xml_result.structure_score,
            structure_result.compatibility_score,
            color_result.structure_score,
            position_result.structure_score,
            alpha_result.structure_score
        ]

        overall_score = sum(scores) / len(scores)
        assert overall_score >= 0.9, f"Overall validation score too low: {overall_score}"

        # All individual validations should pass
        assert xml_result.is_valid
        assert structure_result.is_valid
        assert color_result.is_valid
        assert position_result.is_valid
        assert alpha_result.is_valid


if __name__ == '__main__':
    pytest.main([__file__, '-v'])