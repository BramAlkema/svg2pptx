#!/usr/bin/env python3
"""
End-to-End Tests for IR → Policy → Mapping Pipeline.

Tests the core transformation pipeline from IR data structures through
policy decisions to final DrawingML XML output.
"""

import pytest
from pathlib import Path
import sys
import re

# Add src to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))

try:
    from core.ir import Scene, Path, TextFrame, Group
    from core.ir import Point, Rect, LineSegment, SolidPaint, Stroke
    from core.policies import PolicyEngine
    from core.mappers import SceneMapper, PathMapper, TextMapper
    from lxml import etree
    CORE_PIPELINE_AVAILABLE = True
except ImportError:
    CORE_PIPELINE_AVAILABLE = False
    pytest.skip("Core pipeline components not available", allow_module_level=True)


class TestIRToPolicyPipeline:
    """Test IR to Policy decision pipeline."""

    def test_simple_path_policy_evaluation(self):
        """Test policy evaluation for simple path IR."""
        try:
            # Create simple path IR
            path_ir = Path(
                segments=[LineSegment(Point(0, 0), Point(100, 100))],
                fill=SolidPaint(color="#FF0000"),
                stroke=None,
                is_closed=False,
                data="M 0 0 L 100 100"
            )

            # Evaluate policies
            policy_engine = PolicyEngine()
            decision = policy_engine.evaluate_element(path_ir)

            assert decision is not None
            if hasattr(decision, 'conversion_type'):
                assert decision.conversion_type in ['custom_geometry', 'preset_shape', 'path']
            if hasattr(decision, 'confidence'):
                assert 0 <= decision.confidence <= 1

        except NameError:
            pytest.skip("PolicyEngine not available")

    def test_complex_path_policy_evaluation(self):
        """Test policy evaluation for complex path IR."""
        try:
            # Create complex path with many segments
            segments = []
            for i in range(20):
                segments.append(LineSegment(Point(i*5, 0), Point(i*5+5, 5)))

            complex_path_ir = Path(
                segments=segments,
                fill=SolidPaint(color="#0000FF"),
                stroke=Stroke(paint=SolidPaint(color="#000000"), width=2.0),
                is_closed=False,
                data="M " + " L ".join([f"{i*5} {i%2*5}" for i in range(21)])
            )

            policy_engine = PolicyEngine()
            decision = policy_engine.evaluate_element(complex_path_ir)

            assert decision is not None
            # Complex paths should trigger different policies
            if hasattr(decision, 'complexity_score'):
                assert decision.complexity_score > 5

        except NameError:
            pytest.skip("PolicyEngine not available")

    def test_text_element_policy_evaluation(self):
        """Test policy evaluation for text IR."""
        try:
            from core.ir import TextStyle

            text_ir = TextFrame(
                content="Sample Text",
                bounds=Rect(10, 20, 200, 30),
                style=TextStyle(
                    font_family="Arial",
                    font_size=16,
                    fill=SolidPaint(color="#000000")
                )
            )

            policy_engine = PolicyEngine()
            decision = policy_engine.evaluate_element(text_ir)

            assert decision is not None
            if hasattr(decision, 'conversion_type'):
                assert decision.conversion_type in ['text_frame', 'text_shape', 'path']

        except (NameError, ImportError):
            pytest.skip("PolicyEngine or TextStyle not available")

    def test_group_element_policy_evaluation(self):
        """Test policy evaluation for group IR."""
        try:
            # Create group with child elements
            child_path = Path(
                segments=[LineSegment(Point(0, 0), Point(50, 50))],
                fill=SolidPaint(color="#00FF00"),
                stroke=None,
                is_closed=False,
                data="M 0 0 L 50 50"
            )

            group_ir = Group(
                children=[child_path],
                transform="translate(10, 10) scale(2)",
                clip_id=None
            )

            policy_engine = PolicyEngine()
            decision = policy_engine.evaluate_element(group_ir)

            assert decision is not None
            if hasattr(decision, 'conversion_type'):
                assert decision.conversion_type in ['group_shape', 'flatten', 'preserve_hierarchy']

        except NameError:
            pytest.skip("Group or PolicyEngine not available")

    def test_quality_policy_evaluation(self):
        """Test quality policy evaluation for IR elements."""
        try:
            from core.policies import QualityEngine

            path_ir = Path(
                segments=[LineSegment(Point(0, 0), Point(100, 0))],
                fill=SolidPaint(color="#FF0000"),
                stroke=None,
                is_closed=False,
                data="M 0 0 L 100 0"
            )

            quality_engine = QualityEngine()
            metrics = quality_engine.evaluate_quality(path_ir)

            assert metrics is not None
            if hasattr(metrics, 'fidelity_score'):
                assert 0 <= metrics.fidelity_score <= 100
            if hasattr(metrics, 'performance_score'):
                assert 0 <= metrics.performance_score <= 100

        except (NameError, ImportError):
            pytest.skip("QualityEngine not available")


class TestPolicyToMappingPipeline:
    """Test Policy decision to Mapping pipeline."""

    def test_path_policy_to_mapping(self):
        """Test path mapping based on policy decisions."""
        try:
            # Create path IR
            path_ir = Path(
                segments=[
                    LineSegment(Point(0, 0), Point(100, 0)),
                    LineSegment(Point(100, 0), Point(100, 100)),
                    LineSegment(Point(100, 100), Point(0, 100)),
                    LineSegment(Point(0, 100), Point(0, 0))
                ],
                fill=SolidPaint(color="#FF0000"),
                stroke=None,
                is_closed=True,
                data="M 0 0 L 100 0 L 100 100 L 0 100 Z"
            )

            # Get policy decision
            policy_engine = PolicyEngine()
            decision = policy_engine.evaluate_element(path_ir)

            # Apply mapping based on policy
            path_mapper = PathMapper()
            result = path_mapper.map_path(path_ir, policy_decision=decision)

            assert result is not None
            if isinstance(result, str):
                # Should contain DrawingML path elements
                assert any(element in result.lower() for element in ['custgeom', 'pathlist', 'path'])

        except (NameError, TypeError):
            # policy_decision parameter might not be supported
            try:
                path_mapper = PathMapper()
                result = path_mapper.map_path(path_ir)
                assert result is not None
            except NameError:
                pytest.skip("PathMapper not available")

    def test_text_policy_to_mapping(self):
        """Test text mapping based on policy decisions."""
        try:
            text_ir = TextFrame(
                content="Policy-driven Text",
                bounds=Rect(0, 0, 300, 40),
                style=None
            )

            # Get policy decision
            policy_engine = PolicyEngine()
            decision = policy_engine.evaluate_element(text_ir)

            # Apply mapping based on policy
            text_mapper = TextMapper()
            try:
                result = text_mapper.map_text_frame(text_ir, policy_decision=decision)
            except TypeError:
                # policy_decision parameter might not be supported
                result = text_mapper.map_text_frame(text_ir)

            assert result is not None
            if isinstance(result, str):
                # Should contain DrawingML text elements
                assert any(element in result.lower() for element in ['txbody', 'p', 'r', 't'])
                assert "Policy-driven Text" in result

        except NameError:
            pytest.skip("TextMapper or PolicyEngine not available")

    def test_scene_policy_to_mapping(self):
        """Test scene mapping based on policy decisions."""
        try:
            # Create scene with multiple elements
            path = Path(
                segments=[LineSegment(Point(0, 0), Point(50, 50))],
                fill=SolidPaint(color="#FF0000"),
                stroke=None,
                is_closed=False,
                data="M 0 0 L 50 50"
            )

            text = TextFrame(
                content="Scene Text",
                bounds=Rect(60, 60, 100, 20),
                style=None
            )

            scene_ir = Scene(
                elements=[path, text],
                viewbox=(0, 0, 200, 200),
                width=200,
                height=200
            )

            # Get policy decisions for scene
            policy_engine = PolicyEngine()
            scene_decision = policy_engine.evaluate_element(scene_ir)

            # Apply scene mapping
            scene_mapper = SceneMapper()
            try:
                result = scene_mapper.map_scene(scene_ir, policy_decision=scene_decision)
            except TypeError:
                result = scene_mapper.map_scene(scene_ir)

            assert result is not None
            if isinstance(result, str):
                # Should contain multiple DrawingML elements
                element_count = result.lower().count('<p:sp') + result.lower().count('<a:path')
                assert element_count >= 1

        except NameError:
            pytest.skip("SceneMapper or PolicyEngine not available")


class TestQualityDrivenMapping:
    """Test quality-driven mapping decisions."""

    def test_fidelity_driven_path_mapping(self):
        """Test path mapping optimized for fidelity."""
        try:
            from core.policies import QualityEngine, QualityPolicy

            # Create policy focused on fidelity
            fidelity_policy = QualityPolicy(focus='fidelity')
            quality_engine = QualityEngine(policies=[fidelity_policy])

            # Complex curved path
            try:
                from core.ir import BezierSegment
                curved_path = Path(
                    segments=[BezierSegment(
                        start=Point(0, 100),
                        end=Point(100, 100),
                        control1=Point(50, 0)
                    )],
                    fill=SolidPaint(color="#0000FF"),
                    stroke=None,
                    is_closed=False,
                    data="M 0 100 Q 50 0 100 100"
                )

                # Evaluate quality requirements
                metrics = quality_engine.evaluate_quality(curved_path)

                # Map with quality considerations
                path_mapper = PathMapper()
                result = path_mapper.map_path(curved_path)

                assert result is not None
                # High fidelity should use custom geometry
                if isinstance(result, str):
                    assert any(elem in result.lower() for elem in ['custgeom', 'cubicbezto'])

            except ImportError:
                pytest.skip("BezierSegment not available")

        except (NameError, ImportError):
            pytest.skip("QualityEngine not available")

    def test_performance_driven_mapping(self):
        """Test mapping optimized for performance."""
        try:
            from core.policies import QualityEngine, QualityPolicy

            # Create policy focused on performance
            performance_policy = QualityPolicy(focus='performance')
            quality_engine = QualityEngine(policies=[performance_policy])

            # Simple rectangular path
            rect_path = Path(
                segments=[
                    LineSegment(Point(0, 0), Point(100, 0)),
                    LineSegment(Point(100, 0), Point(100, 100)),
                    LineSegment(Point(100, 100), Point(0, 100)),
                    LineSegment(Point(0, 100), Point(0, 0))
                ],
                fill=SolidPaint(color="#00FF00"),
                stroke=None,
                is_closed=True,
                data="M 0 0 L 100 0 L 100 100 L 0 100 Z"
            )

            # Evaluate performance requirements
            metrics = quality_engine.evaluate_quality(rect_path)

            # Map with performance considerations
            path_mapper = PathMapper()
            result = path_mapper.map_path(rect_path)

            assert result is not None
            # Performance-optimized might use preset shapes
            if isinstance(result, str) and hasattr(metrics, 'performance_score'):
                # Should produce efficient DrawingML
                assert len(result) < 10000  # Reasonable size limit

        except (NameError, ImportError):
            pytest.skip("QualityEngine not available")

    def test_size_optimized_mapping(self):
        """Test mapping optimized for file size."""
        try:
            from core.policies import QualityEngine, QualityPolicy

            # Create policy focused on file size
            size_policy = QualityPolicy(focus='file_size')
            quality_engine = QualityEngine(policies=[size_policy])

            # Text element
            text_ir = TextFrame(
                content="Size-optimized text content",
                bounds=Rect(0, 0, 300, 30),
                style=None
            )

            # Evaluate size requirements
            metrics = quality_engine.evaluate_quality(text_ir)

            # Map with size considerations
            text_mapper = TextMapper()
            result = text_mapper.map_text_frame(text_ir)

            assert result is not None
            if isinstance(result, str):
                # Size-optimized should be concise
                # Should avoid redundant attributes and use efficient encoding
                assert len(result) < 5000  # Reasonable size limit

        except (NameError, ImportError):
            pytest.skip("QualityEngine not available")


class TestConditionalMappingPipeline:
    """Test conditional mapping based on policy decisions."""

    def test_complex_element_conditional_mapping(self):
        """Test conditional mapping for complex elements."""
        try:
            # Create complex path that might trigger different policies
            complex_segments = []
            for i in range(50):
                complex_segments.append(LineSegment(Point(i*2, 0), Point(i*2+1, 1)))

            complex_path = Path(
                segments=complex_segments,
                fill=SolidPaint(color="#800080"),
                stroke=None,
                is_closed=False,
                data="M " + " L ".join([f"{i*2} {i%2}" for i in range(51)])
            )

            # Evaluate with multiple policies
            policy_engine = PolicyEngine()
            decision = policy_engine.evaluate_element(complex_path)

            # Map based on complexity decision
            path_mapper = PathMapper()
            result = path_mapper.map_path(complex_path)

            assert result is not None
            if isinstance(result, str):
                # Complex elements might be simplified or use custom geometry
                assert len(result) > 100  # Should have substantial content

        except NameError:
            pytest.skip("PolicyEngine or PathMapper not available")

    def test_fallback_mapping_strategies(self):
        """Test fallback mapping strategies."""
        try:
            # Create element that might not have ideal mapping
            edge_case_path = Path(
                segments=[],  # Empty segments (edge case)
                fill=None,
                stroke=None,
                is_closed=False,
                data=""
            )

            # Should handle gracefully
            policy_engine = PolicyEngine()
            try:
                decision = policy_engine.evaluate_element(edge_case_path)

                path_mapper = PathMapper()
                result = path_mapper.map_path(edge_case_path)

                # Should produce some result even for edge cases
                assert result is not None

            except (ValueError, TypeError):
                # Edge cases might be rejected at policy level
                pass

        except NameError:
            pytest.skip("PolicyEngine or PathMapper not available")

    def test_multi_element_coordination(self):
        """Test coordination between multiple element mappings."""
        try:
            # Create scene with related elements
            background_rect = Path(
                segments=[
                    LineSegment(Point(0, 0), Point(200, 0)),
                    LineSegment(Point(200, 0), Point(200, 150)),
                    LineSegment(Point(200, 150), Point(0, 150)),
                    LineSegment(Point(0, 150), Point(0, 0))
                ],
                fill=SolidPaint(color="#F0F0F0"),
                stroke=None,
                is_closed=True,
                data="M 0 0 L 200 0 L 200 150 L 0 150 Z"
            )

            title_text = TextFrame(
                content="Coordinated Content",
                bounds=Rect(50, 20, 100, 30),
                style=None
            )

            scene_ir = Scene(
                elements=[background_rect, title_text],
                viewbox=(0, 0, 200, 150),
                width=200,
                height=150
            )

            # Policy should consider element relationships
            policy_engine = PolicyEngine()

            # Map scene with coordination
            scene_mapper = SceneMapper()
            result = scene_mapper.map_scene(scene_ir)

            assert result is not None
            if isinstance(result, str):
                # Should contain both background and text
                assert "Coordinated Content" in result
                # Should have proper layering/ordering

        except NameError:
            pytest.skip("SceneMapper or PolicyEngine not available")


class TestMappingOutputValidation:
    """Test validation of mapping output."""

    def test_drawingml_xml_structure_validation(self):
        """Test that mapping output produces valid DrawingML XML."""
        try:
            path_ir = Path(
                segments=[LineSegment(Point(0, 0), Point(100, 100))],
                fill=SolidPaint(color="#FF0000"),
                stroke=None,
                is_closed=False,
                data="M 0 0 L 100 100"
            )

            path_mapper = PathMapper()
            result = path_mapper.map_path(path_ir)

            assert result is not None
            if isinstance(result, str):
                # Should be valid XML
                try:
                    # Try parsing as complete XML
                    etree.fromstring(result)
                except etree.XMLSyntaxError:
                    # Try as XML fragment
                    wrapped = f"<root xmlns:a='http://schemas.openxmlformats.org/drawingml/2006/main'>{result}</root>"
                    etree.fromstring(wrapped)

        except NameError:
            pytest.skip("PathMapper not available")

    def test_powerpoint_namespace_compliance(self):
        """Test that output uses correct PowerPoint namespaces."""
        try:
            text_ir = TextFrame(
                content="Namespace Test",
                bounds=Rect(0, 0, 200, 30),
                style=None
            )

            text_mapper = TextMapper()
            result = text_mapper.map_text_frame(text_ir)

            assert result is not None
            if isinstance(result, str):
                # Should contain PowerPoint namespaces
                expected_namespaces = ['a:', 'p:', 'r:']
                found_namespaces = [ns for ns in expected_namespaces if ns in result]
                assert len(found_namespaces) > 0

        except NameError:
            pytest.skip("TextMapper not available")

    def test_coordinate_system_compliance(self):
        """Test that coordinates are properly converted to EMU."""
        try:
            rect_path = Path(
                segments=[
                    LineSegment(Point(1, 1), Point(2, 1)),
                    LineSegment(Point(2, 1), Point(2, 2)),
                    LineSegment(Point(2, 2), Point(1, 2)),
                    LineSegment(Point(1, 2), Point(1, 1))
                ],
                fill=SolidPaint(color="#0000FF"),
                stroke=None,
                is_closed=True,
                data="M 1 1 L 2 1 L 2 2 L 1 2 Z"
            )

            path_mapper = PathMapper()
            result = path_mapper.map_path(rect_path)

            assert result is not None
            if isinstance(result, str):
                # Should contain EMU-scale coordinates (large numbers)
                numbers = re.findall(r'\d{4,}', result)  # Find numbers with 4+ digits
                assert len(numbers) > 0  # Should have EMU coordinates

        except NameError:
            pytest.skip("PathMapper not available")


class TestPipelinePerformance:
    """Test IR → Policy → Mapping pipeline performance."""

    def test_policy_evaluation_performance(self):
        """Test policy evaluation performance."""
        try:
            import time

            # Create test elements
            elements = []
            for i in range(20):
                path = Path(
                    segments=[LineSegment(Point(i, 0), Point(i+10, 10))],
                    fill=SolidPaint(color=f"#{i:02x}0000"),
                    stroke=None,
                    is_closed=False,
                    data=f"M {i} 0 L {i+10} 10"
                )
                elements.append(path)

            # Time policy evaluation
            policy_engine = PolicyEngine()
            start_time = time.time()

            decisions = []
            for element in elements:
                decision = policy_engine.evaluate_element(element)
                decisions.append(decision)

            evaluation_time = time.time() - start_time

            assert len(decisions) == 20
            assert evaluation_time < 0.1  # Should evaluate quickly

        except NameError:
            pytest.skip("PolicyEngine not available")

    def test_mapping_performance(self):
        """Test mapping performance."""
        try:
            import time

            # Create test paths
            paths = []
            for i in range(10):
                path = Path(
                    segments=[LineSegment(Point(i*5, 0), Point(i*5+20, 20))],
                    fill=SolidPaint(color="#FF0000"),
                    stroke=None,
                    is_closed=False,
                    data=f"M {i*5} 0 L {i*5+20} 20"
                )
                paths.append(path)

            # Time mapping
            path_mapper = PathMapper()
            start_time = time.time()

            results = []
            for path in paths:
                result = path_mapper.map_path(path)
                results.append(result)

            mapping_time = time.time() - start_time

            assert len(results) == 10
            assert mapping_time < 0.5  # Should map reasonably quickly

        except NameError:
            pytest.skip("PathMapper not available")

    def test_end_to_end_pipeline_performance(self):
        """Test complete pipeline performance."""
        try:
            import time

            # Create scene with multiple elements
            elements = []
            for i in range(15):
                if i % 3 == 0:
                    # Add path
                    path = Path(
                        segments=[LineSegment(Point(i*10, 0), Point(i*10+15, 15))],
                        fill=SolidPaint(color="#0000FF"),
                        stroke=None,
                        is_closed=False,
                        data=f"M {i*10} 0 L {i*10+15} 15"
                    )
                    elements.append(path)
                else:
                    # Add text
                    text = TextFrame(
                        content=f"Text {i}",
                        bounds=Rect(i*20, 30, 50, 20),
                        style=None
                    )
                    elements.append(text)

            scene_ir = Scene(
                elements=elements,
                viewbox=(0, 0, 300, 200),
                width=300,
                height=200
            )

            # Time complete pipeline
            start_time = time.time()

            # Policy evaluation
            policy_engine = PolicyEngine()
            scene_decision = policy_engine.evaluate_element(scene_ir)

            # Mapping
            scene_mapper = SceneMapper()
            result = scene_mapper.map_scene(scene_ir)

            total_time = time.time() - start_time

            assert result is not None
            assert total_time < 1.0  # Complete pipeline should be fast

        except NameError:
            pytest.skip("Policy and mapping components not available")


if __name__ == "__main__":
    pytest.main([__file__])